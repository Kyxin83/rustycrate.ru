---
layout: post
categories: новости
title: "Выпуск Rust 1.31 и Rust 2018"
author: The Rust Core Team
original: https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html
translator: XX
---

Команда разработчиков Rust рада сообщить о выпуске новой версии Rust, 1.31.0, а
также "Rust 2018". Rust - это язык программирования, который дает возможность каждому
создавать надежное и эффективное программное обеспечение.

Если у вас установлена предыдущая версия Rust с помощью `rustup`, то для обновления
Rust до версии 1.31.0 вам достаточно выполнить:

```bash
$ rustup update stable
```

Если у вас еще не установлен `rustup`, вы можете [установить его][install] с соответствующей
страницы нашего веб-сайта. С [подробными примечаниями к выпуску Rust 1.31.0][notes]
можно ознакомиться на GitHub.

[install]: https://www.rust-lang.org/tools/install
[notes]: https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06

## Что вошло в стабильную версию 1.31.0

Rust 1.31, возможно, самый значительный выпуск со времен Rust 1.0! В данный выпуск включена
первая итерация «Rust 2018», но и не только она! Это будет длинный обзор, поэтому вот оглавление:

* [Rust 2018](#rust-2018)
  * [Нелексические времена жизни](#non-lexical-lifetimes)
  * [Изменения системы модулей](#module-system-changes)
* [Дополнительные правила вывода времен жизни](#more-lifetime-elision-rules)
* [`const fn`](#const-fn)
* [Новые инструменты](#new-tools)
* [Tool Lints](#tool-lints)
* [Документация](#documentation)
* [Предметные рабочие группы](#domain-working-groups)
* [Новый сайт](#new-website)
* [Стабилизация стандартной библиотеки](#library-stabilizations)
* [Улучшения в Cargo](#cargo-features)
* [Разработчики выпуска](#contributors-to-1310)

<!--cut-->

### Rust 2018

Мы писали о Rust 2018 [впервые в марте](https://blog.rust-lang.org/2018/03/12/roadmap.html),
и затем [в июле](https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html).
За подробностями *зачем* нужен Rust 2018, обратитесь к этим публикациям. В данном
анонсе нам и так много что нужно рассказать, поэтому мы сосредоточимся только на том,
*что* такое Rust 2018. Также об этом можно почитать [в посте на Mozilla Hacks][hacks].

[hacks]: https://hacks.mozilla.org/2018/12/rust-2018-is-here/

Вкратце, Rust 2018 - это возможность объединить в связное целое всю работу,
которую мы проделали за последние три года. Он - нечто большее, чем просто
набор улучшений языка. Он также включает:

* Инструментарий (поддержка в IDE, `rustfmt`, Clippy)
* Документацию
* Работу предметных рабочих групп
* Новый веб-сайт

Мы расскажем тут обо всех этих пунктах и многом другом.

Давайте создадим новый проект с помощью Cargo:

```console
$ cargo new foo
```

Вот содержимое `Cargo.toml`:

```toml
[package]
name = "foo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"

[dependencies]
```

В секцию `[package]` был добавлен новый ключ: `edition`. Обратите внимание,
что он установлен в `2018`. Вы также можете установить его в `2015` - это
значение будет установлено по умолчанию, если ключ отсутствует.

С использованием Rust 2018 будут разблокированы некоторые новые возможности,
которые не разрешены в Rust 2015.

Важно отметить, что каждый пакет может быть в режиме 2015 или 2018, и они
будут работать вместе. Ваш проект 2018 редакции может использовать зависимости
2015 редакции, а проект 2015 редакции может использовать зависимости 2018
редакции. Это гарантирует, что мы не разделим экосистему, и все новые
возможности будут включены, сохраняя совместимость с существующим кодом.
Кроме того, когда вы решите перенести код Rust 2015 на Rust 2018, изменения
могут быть внесены автоматически через `cargo fix`.

Вы можете спросить: а что за "новые возможности"? Во-первых, улучшения
добавляются также и в Rust 2015, если они совместимы с особенностями этой
редакции. Таким образом, большая часть языка одинаковая везде. Вы можете
посмотреть [руководство по редакциям](https://doc.rust-lang.org/edition-guide)
чтобы узнать минимальную версию `rustc` для каждой новой возможности, а
также требования редакции. Однако, есть несколько больших нововведений, о
которых нужно упомянуть: нелексические времена жизни и некоторые
улучшения системы модулей.

#### Нелексические времена жизни

Если вы следили за развитием Rust последние несколько лет, то вы могли
время от времени встречать термин "NLL" или "нелексические времена жизни"
("non-lexical lifetimes"). Это - жаргонизм, который, если говорить простыми
словами, означает: анализатор заимствований стал умнее и теперь принимает
некоторый валидный код, который до этого отклонял. Рассмотрим пример:

```rust
fn main() {
    let mut x = 5;

    let y = &x;

    let z = &mut x;
}
```

Раньше Rust выдавал ошибку компиляции:

```text
error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --> src/main.rs:5:18
  |
4 |     let y = &x;
  |              - immutable borrow occurs here
5 |     let z = &mut x;
  |                  ^ mutable borrow occurs here
6 | }
  | - immutable borrow ends here
```

Это потому, что область жизни ссылок определялась "лексически"; то есть,
заимствование `y` считалось активным, пока `y` не выйдет из области видимости
в конце `main`, даже если мы никогда больше не используем `y` внутри области.
С кодом выше все в порядке, но анализатор зависимостей не мог этого понять.

Теперь этот код замечательно скомпилируется.

Но что, если бы мы использовали `y`, например так:

```rust
fn main() {
    let mut x = 5;
    let y = &x;
    let z = &mut x;
    
    println!("y: {}", y);
}
```

Раньше Rust выдавал вам такую ошибку:

```text
error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --> src/main.rs:5:18
  |
4 |     let y = &x;
  |              - immutable borrow occurs here
5 |     let z = &mut x;
  |                  ^ mutable borrow occurs here
...
8 | }
  | - immutable borrow ends here
```

В Rust 2018 это сообщение об ошибке улучшилось:

```text
error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --> src/main.rs:5:13
  |
4 |     let y = &x;
  |             -- immutable borrow occurs here
5 |     let z = &mut x;
  |             ^^^^^^ mutable borrow occurs here
6 |     
7 |     println!("y: {}", y);
  |                       - borrow later used here
```

Вместо того, чтобы указывать, где `y` выходит из области видимости, оно
показывает, где происходит конфликтное заимствование. Это значительно
упрощает отладку ошибок такого рода.

В Rust 1.31 это улучшение исключительно для Rust 2018. Мы планируем добавить
его в Rust 2015 позже.

#### Изменения системы модулей

Система модулей может вызывать затруднения у людей, впервые изучающих
Rust. Конечно, всегда есть что-то, для освоения чего требуется время.
Но есть коренная причина того, почему модули так смущают многих: хотя
есть простые и последовательные правила, определяющие систему
модулей, последствия их применения могут казаться противоречивыми,
загадочными и противоестественными.

Таким образом, редакция 2018 вносит некоторые изменения в то, как работают
пути импорта. В итоге они упрощают систему модулей, делая ее более понятной.

Вот краткое резюме:

* `extern crate` больше не требуется практически во всех случаях.
* Вы можете импортировать макросы с помощью `use`, вместо использования атрибута `#[macro_use]`.
* Абсолютные пути начинаются с имени контейнера, где ключевое слово `crate` относится к текущему контейнеру.
* `foo.rs` и поддиректория `foo/` могут сосуществовать; `mod.rs` больше не требуется при размещении подмодулей в поддиректории.

Это выглядит как произвольный набор правил, но в целом ментальная модель
теперь значительно упростилась.

Тут еще *много* деталей, пожалуйста, обратитесь к [руководству по
редакциям](https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html)
за выяснением всех подробностей.

### Дополнительные правила вывода времен жизни

Давайте поговорим об улучшении, доступном в обоих редакциях: мы
добавили некоторые дополнительные правила вывода для блоков `impl`
и определений функций. Код вроде такого:

```rust
impl<'a> Reader for BufReader<'a> {
    // здесь методы
}
```

может быть теперь записан так:

```rust
impl Reader for BufReader<'_> {
    // здесь методы
}
```

Время жизни `'_` по-прежнему показывает, что` BufReader` принимает его как
параметр, но нам больше не нужно задавать для него имя.

Времена жизни все еще требуется определять в структурах. Однако нам больше
не нужно писать столько шаблонного кода, как раньше:

```rust
// Rust 2015
struct Ref<'a, T: 'a> {
    field: &'a T
}

// Rust 2018
struct Ref<'a, T> {
    field: &'a T
}
```

Зависимость `: 'a` будет выведена. Вы все еще можете указать ее явно, если
хотите. Мы рассматриваем и другие возможности для вывода в подобных местах
на будущее, но пока не имеем конкретных планов.

### `const fn`

В Rust есть несколько способов объявления функции: `fn` для обычной функции,
`unsafe fn` для небезопасной функции и `extern fn` для внешних функций.
В этом выпуске добавлен новый способ объявления функции: `const fn`. Он
используется так:

```rust
const fn foo(x: i32) -> i32 {
    x + 1
}
```

Константная функция может вызываться как обычная функция, но помимо этого
она может использоваться в любом константном контексте. Если так, то она
выполнится во время компиляции, а не во время выполнения программы. Например:

```rust
const SIX: i32 = foo(5);
```

Функция `foo` выполнится во время компиляции и `SIX` примет значение `6`.

Константные функции не могут делать все то, что могут нормальные функции;
они должны иметь детерминированный результат. Это важно из соображений
надежности. В текущем виде константные функции могут совершать минимальное
подмножество операций. Вот некоторые примеры того, что вы можете в них делать:

* Целочисленные арифметические операции и операции сравнения
* Все булевые операции, кроме `&&` и `||`
* Конструировать массивы, структуры, перечисления и кортежи
* Вызывать другие константные функции
* Обращаться по индексу в массивах и срезах
* Обращаться к полям структур и кортежей
* Использовать константы (но не статические значения, и даже не ссылки на них)
* Использовать `&` и `*` ссылки
* Приводить типы, исключая приведение сырого указателя к целочисленному значению

Мы будем расширять возможности константных функций, но приведенного
выше набора уже достаточно, чтобы `const fn` попала в выпуск.

Подробности смотрите [в справочнике](https://doc.rust-lang.org/reference/items/functions.html#const-functions).

### Новые инструменты

Редакция 2018 знаменует начало нового уровня зрелости экосистемы инструментов
Rust. Cargo, Rustdoc и Rustup были основными инструментами, начиная с версии
1.0; с редакцией 2018 приходит новое поколение инструментов, которыми теперь
все могут пользоваться: Clippy, Rustfmt и поддержка IDE.

Статический анализатор кода [`clippy`](https://github.com/rust-lang/rust-clippy/)
теперь доступен в стабильном Rust. Вы можете установить его через `rustup component
add clippy` и запустить командой `cargo clippy`. Clippy теперь принимает
версию 1.0 и имеет такие же гарантии стабильности статических проверок, что и rustc.
Новые проверки могут добавляться, или может расширяться функционал старых,
но старые не могут быть удалены (могут быть только помечены как устаревшие).
Это означает, что код, который компилируется с clippy, будет продолжать
компилироваться с clippy (при условии, что для проверок не задано генерировать
ошибку через `deny`), но может выдавать новые предупреждения.

[Rustfmt](https://github.com/rust-lang/rustfmt) - это инструмент для форматирования
кода в Rust. Автоматическое форматирование кода позволит вам сэкономить время,
кроме того, оно приблизит ваш код к [официальному стилю
Rust](https://github.com/rust-lang/rfcs/blob/master/style-guide/README.md).
Вы можете установить его через `rustup component add rustfmt` и использовать
командой `cargo fmt`.

Текущий выпуск включает Rustfmt 1.0. Отныне мы гарантируем обратную
совместимость для Rustfmt: если вы отформатируете свой код сегодня,
то форматирование не изменится в будущем (только для параметров по
умолчанию). Обратная совместимость означает, что теперь практично
запускать Rustfmt на вашем CI (используйте `cargo fmt --check`).
Попробуйте это и "форматирование при сохранении" в редакторе, чтобы
революционизировать ваш рабочий процесс.

Поддержка IDE - одна из самых востребованных возможностей инструментов
для Rust. Сейчас имеется несколько вариантов решения высокого качества:

* [Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust)
* [IntelliJ](https://plugins.jetbrains.com/plugin/8182-rust)
* [Atom](https://github.com/rust-lang-nursery/atom-ide-rust)
* [Sublime Text 3](https://github.com/rust-lang/rust-enhanced)
* [Eclipse](https://www.eclipse.org/downloads/packages/release/photon/r/eclipse-ide-rust-developers-includes-incubating-components)

Работа по поддержке в IDE не закончена. В частности, автодополнение кода
в редакторах, основанных на RLS, не на высоте. Однако, если вы в основном
хотите поддержку типов, документации и "перехода к определению", тогда вы
останетесь довольны.

### Tool lints

In [Rust 1.30](https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html), we
stabilized "tool attributes", like `#[rustfmt::skip]`. In Rust 1.31, we're
stabilizing something similar: "tool lints," like
`#[allow(clippy::bool_comparison)]` These give a namespace to lints, so that it's
more clear which tool they're coming from.

If you previously used Clippy's lints, you can migrate like this:

```rust
// old
#![cfg_attr(feature = "cargo-clippy", allow(bool_comparison))]

// new
#![allow(clippy::bool_comparison)]
```

You don't need `cfg_attr` anymore! You'll also get warnings that can help you
update to the new style.

### Documentation

Rustdoc has seen a number of improvements this year, and we also shipped a
complete re-write of the "The Rust Programming Language." Additionally, you
can [buy a dead-tree copy from No Starch Press](https://nostarch.com/rust)!

We had previously called this the "second edition" of the book, but since
it's the first edition in print, that was confusing. We also want to
periodically update the print edition as well. In the end, after many
discussions with No Starch, we're going to be updating the book on the
website with each release, and No Starch will periodically pull in our
changes and print them. The book has been selling quite well so far, raising
money for [Black Girls Code](http://www.blackgirlscode.com/).

You can find the new TRPL [here](https://doc.rust-lang.org/beta/book/).

### Domain working groups

We announced the formation of four working groups this year:

* Network services
* Command-line applications
* WebAssembly
* Embedded devices

Each of these groups has been working very hard on a number of things to
make Rust awesome in each of these domains. Some highlights:

* Network services has been shaking out the Futures interface, and async/await
  on top of it. This hasn't shipped yet, but we're close!
* The CLI working group has been working on libraries and documentation for making awesome
  command-line applications
* The WebAssembly group has been shipping a ton of world-class tooling for using Rust with wasm.
* Embedded devices has gotten ARM development working on stable Rust!

You can find out more about this work on the new website!

### New Website

[Last
week](https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html)
we announced a new iteration of the web site. It's now been promoted to
rust-lang.org itself!

There's still a ton of work to do, but we're proud of the year of work that it
took by many people to get it shipped.

### Стабилизация стандартной библиотеки

Были добавлены новые реализации `From`:

* `u8` теперь реализует `From<NonZeroU8>`, аналогично и для других числовых типов и их `NonZero` эквивалентов
* `Option<&T>` реализует `From<&Option<T>>`, аналогично и для `&mut`

Также были стабилизированы следующие функции:

* [`slice::align_to`](https://doc.rust-lang.org/std/primitive.slice.html#method.align_to) и его мутабельный аналог
* [`slice::chunks_exact`](https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact),
  а также его мутабельный и `r` аналоги (такие как
  [`slice::rchunks_exact_mut`](https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut)) во всех комбинациях

Подробности смотрите [в примечаниях к выпуску][notes].

### Улучшения в Cargo

Cargo теперь будет загружать пакеты параллельно, используя HTTP/2.

Кроме того, теперь, когда `extern crate` указывать обычно не требуется, было
бы неприятно писать `extern crate foo as bar;` для переименования зависимости.
Поэтому вы можете делать это в `Cargo.toml` таким образом:

```toml
[dependencies]
baz = { version = "0.1", package = "foo" }
```

или, что эквивалентно:

```toml
[dependencies.baz]
version = "0.1"
package = "foo"
```

Теперь пакет `foo` будет доступен как `baz` для использования в вашем коде.

Подробности смотрите [в примечаниях к выпуску][notes].

## Разработчики 1.31.0

At the end of release posts, we normally thank [the people who contributed to
this release](https://thanks.rust-lang.org/rust/1.31.0). But for this
release, more so than others, this list does not truly capture the amount of
work and the number of people who have contributed. Each release is only six
weeks, but this release is the culmination of three years of effort, in
countless repositories, by numerous people. It's been a pleasure to work with
you all, and we look forward to continuing to grow in the next three years.
