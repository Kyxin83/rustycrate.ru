---
categories: новости
title: "Выпуск Rust 1.24"
author: The Rust Core Team
original: https://blog.rust-lang.org/2018/02/15/Rust-1.24.html
translator: LooMaclin
---

Команда Rust рада сообщить о новой версии Rust: 1.24.0. Rust — это системный
язык программирования, нацеленный на безопасность, скорость и параллельное
выполнение кода.

Если у вас установлена предыдущая версия Rust, для обновления достаточно
выполнить:

```
$ rustup update stable
```

Если же у вас еще не установлен rustup, вы можете [установить его][install] с
соответствующей страницы нашего веб-сайта. С
[подробными примечаниями к выпуску Rust 1.24.0][notes] можно ознакомиться на
GitHub.

[install]: https://www.rust-lang.org/install.html
[notes]: https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1240-2018-02-15

# Что вошло в стабильную версию 1.24.0

Этот выпуск содержит два очень интересных нововведения:
`rustfmt` и инкрементальную компиляцию!

<!--cut-->

## rustfmt

В течение многих лет нам нужен был инструмент, который мог бы автоматически
форматировать `Rust` код в какой-то "стандартный" стиль.
В этом выпуске мы рады объявить о выходе предварительной версии `rustfmt`,
которая может быть использована со стабильной версией 1.24.
Чтобы попробовать, выполните следующую команду:

```
$ rustup component add rustfmt-preview
```

Здесь есть два важных момента: во-первых, необходимо использовать
`rustup component add` вместо `cargo install`.
Если вы до этого использовали `rustfmt`, установленный через `cargo install`,
вы должны удалить его в первую очередь.
Во-вторых, это предварительная версия, как и сказано в названии.
`rustfmt` пока не достиг версии 1.0 и мы ещё исправляем и настраиваем некоторые
вещи. Как только `rustfmt` достигнет версии 1.0, мы выпустим компонент `rustfmt`,
а `rustfmt-preview` будет считаться устаревшим.

В ближайшем будущем мы планируем написать пост об стратегии выпуска `rustfmt`,
поскольку информации будет много и она выходит за рамки поста данного релиза.

Больше информации можно узнать на
[странице `rustfmt` на github](https://github.com/rust-lang-nursery/rustfmt).

## Инкрементальная компиляция

Ещё в сентябре 2016 года мы писали об
[инкрементальной компиляции](https://blog.rust-lang.org/2016/09/08/incremental.html).
Этот пост вдавался в подробности, о том как она работает,
но ключевая идея такова: когда вы работаете
над проектом, приходится часто компилировать его после небольших изменений в коде.
Исторически так сложилось, что независимо от объёма изменений компилировался весь ваш код.
Идея инкрементальной компиляции - компиляция только того кода,
который действительно изменился. Это обеспечивает ускорение последующих компиляций.

Начиная с версии 1.24, это будет [включено по умолчанию](https://github.com/rust-lang/cargo/pull/4817).
Это означает, что ваши сборки
будут быстрее. Не забывайте также о команде `cargo check`, которая позволит
получить минимальное время сборки (*прим. перев.*:
эта команда не собирает бинарный файл, а лишь проверяет корректность кода,
но всё равно ведёт к ускорению сборки в отладочном режиме,
т.к. кэш инкрементальной компиляции, насколько я понимаю, у них общий).

Это не конец работ по производительности компилятора и инкрементальной
компиляции. В будущем мы планируем намного больше работы в этой области. 
Например, в этом выпуске мы стабилизировали ещё одно изменение, влияющее на производительность:
[`codegen-units` теперь установлены в 16 по умолчанию](https://github.com/rust-lang/rust/pull/46910).
Оно делает сборку быстрее, но конечный код будет немного медленней.
Для максимальной производительности итогового кода необходимо выставить
`codegen-units` равным `1` в `Cargo.toml` вашего проекта.

## Другие изменения

Есть ещё одно изменение, о котором мы хотели упомянуть здесь: неопределенное поведение (UB).
`Rust` стремится минимизировать неопределённое поведение: в безопасном коде его не должно быть совсем,
а в небезопасном его должно быть по минимуму.
Раньше вы могли вызвать неопределённое поведение в безопасном коде, 
выполнив `panic!` в FFI-функции. Например, так:

```rust
extern "C" fn panic_in_ffi() {
    panic!("Test");
}
```

Это не может работать, поскольку точный механизм работы паники должен быть
согласован с `C` ABI --- в данном случае; или с другим ABI в
случае вызова из другой среды исполнения.

В Rust 1.24 этот код
[теперь прерывается](https://github.com/rust-lang/rust/pull/46833) (abort),
а не создает неопределенное поведение.

Подробности смотрите [в примечаниях к выпуску][notes].

## Стабилизация библиотек

Если вы фанат функции `str::find`, которая используется, чтобы найти необходимый
`char` в `&str` вас порадует это изменение:
[теперь она в 10 раз быстрее](https://github.com/rust-lang/rust/pull/46735)!
Это случилось благодаря `memchr`. `[u8]::contains` также
[использует](https://github.com/rust-lang/rust/pull/46713) её, но ускоряется
не так сильно.

Также в этом выпуске стабилизированы несколько новых API:

- [`RefCell::replace`]
- [`RefCell::swap`]
- [`std::sync::atomic::spin_loop_hint`]

[`RefCell::replace`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace
[`RefCell::swap`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.swap
[`std::sync::atomic::spin_loop_hint`]: https://doc.rust-lang.org/std/sync/atomic/fn.spin_loop_hint.html

Теперь следующие функции могут быть использованы в константных выражениях
(например, чтобы инициализировать `static`):
- Функции `new`  для `Cell`, `RefCell`, и `UnsafeCell`
- Функции `new` для различных числовых типов `Atomic*` (`AtomicBool`,
`AtomicIsize`, `AtomicUsize`)
- `{integer}::min_value` и `{integer}::max_value`
- `mem::size_of` и `mem::align_of`
- `ptr::null` и `ptr::null_mut`

Подробности смотрите [в примечаниях к выпуску][notes].

### Улучшения Cargo

Самое большое изменение - включение инкрементальной компиляции по умолчанию, как
было упомянуто выше.

Подробности смотрите [в примечаниях к выпуску][notes].

## Разработчики 1.24

Множество людей участвовало в разработке Rust 1.24. Мы не смогли бы этого
добиться без участия каждого из вас.
[Спасибо!](https://blog.rust-lang.org/2018/02/15/Rust-1.24.html)
