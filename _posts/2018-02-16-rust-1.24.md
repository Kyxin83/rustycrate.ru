---
layout: post
categories: новости
title: "Выпуск Rust 1.24"
author: The Rust Core Team
original: https://blog.rust-lang.org/2018/02/15/Rust-1.24.html
translator: LooMaclin
---

Команда Rust рада сообщить о новой версии Rust: 1.24.0. Rust — это системный
язык программирования, нацеленный на безопасность, скорость и параллельное
выполнение кода.

Если у вас установлена предыдущая версия Rust, для обновления достаточно
выполнить:

```
$ rustup update stable
```

Если же у вас еще не установлен rustup, вы можете установить его с
соответствующей страницы нашего веб-сайта. С
[подробными примечаниями к выпуску Rust 1.24.0]
(https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1240-2018-02-15)
можно ознакомиться на GitHub.

# Что вошло в стабильную версию 1.24.0

Этот релиз содержит две очень интересные новые фичи: `rustfmt` и инкрементальную
компиляцию!

<!--cut-->

## rustfmt

В течении многих лет нам нужен был инструмент, который мог бы автоматически
форматировать `Rust` код в какой-то "стандартный" стиль. В этом выпуске мы рады
анонсировать превью `rustfmt`, которая может быть использована со стабильной
версией 1.24. Чтобы попробовать, выполните следующие команды:

```
$ rustup component add rustfmt-preview
```

Здесь есть два важных момента: во-первых, вы используете `rustup component add`
вместо `cargo install`. Если вы до этого использовали `rustfmt` установленный
через `cargo install` вы должны удалить его в первую очередь. Во-вторых, это
превью, как и сказано в названии. `rustfmt` пока не достиг версии 1.0 и
некоторые вещи ещё настраиваются, а также исправляются ошибки. Как только
`rustfmt` достигнет версии 1.0 мы выпустим компоненту `rustfmt`, а
`rustfmt-preview` будет считаться устаревшей.

В ближайшем будущем мы планируем написать пост об этой релизной стратегии,
информации будет много и она выходит за рамки поста данного релиза.

Для большей информации можете посетить
[страницу `rustfmt` на github](https://github.com/rust-lang-nursery/rustfmt).

## Инкрементальная компиляция

Ещё в сентябре 2016 года мы писали о [инкрементальной компиляции]
(https://blog.rust-lang.org/2016/09/08/incremental.html). Этот пост вдавался в
подробности, о том как она работает, но ключевая идея такова: когда вы работаете
над проектом приходится часто компилировать его, меняя небольшие участки кода и
опять компилировать. Исторически так сложилось, что компилировался весь ваш код
независимо от того насколько небольшими были ваши изменения. Идея
инкрементальной компиляции состоит в том, чтобы компилировать только тот код,
который действительно изменился, это означает что последующие компиляции будут
быстрее.

Начиная с версии 1.24, это будет [включено по-умолчанию]
(https://github.com/rust-lang/cargo/pull/4817). Это означает, что ваши сборки
будут быстрее. Не забывайте также, о команде `cargo check`, которая позволит
получить минимальное время сборки (примечание: эта команда не билдит бинарь,
лишь проверяет корректность кода, но всё равно ведёт к ускорению билда в дебаг
режиме так как кэш инкрементальной компиляции насколько я понимаю у них общий).
Это не конец работ по производительности компилятора и инкрементальной
компиляции. В будущем мы планируем намного больше работы над этим. Например, ещё
одно изменение влияющее на производительность стабилизированное в этом релизе:
[`codegen-units` теперь установлены в 16 по-умолчанию]
(https://github.com/rust-lang/rust/pull/46910). Небольшая заметка об этом
изменении: оно делает билд быстрее, но конечный код будет немного медленней.
Для максимальной производительности итогового кода необходимо выставить
`codegen-units` равным `1` в `Cargo.toml` вашего проекта.

## Другие изменения вошедшие в релиз

Есть ещё одно изменение, о котором мы хотели упомянуть здесь: UB. `Rust`
стремится минимизировать UB не имея ни одного в безопасном коде и как можно
меньше в небезопасном. Одна область где вы могли встретить UB, это `panic!`
вызванный из FFI. Например так:

```rust
extern "C" fn panic_in_ffi() {
    panic!("Test");
}
```

Это не может работать, поскольку точный механизм работы паники должен быть
согласован с тем, как работает `C` ABI, в этом примере, или любой другой ABI в
других примерах.

В Rust 1.24 этот код
[теперь прерывается](https://github.com/rust-lang/rust/pull/46833), а не создает
неопределенное поведение.

## Стабилизация библиотек

Если вы фанат функции `str::find`, которая используется, чтобы найти необходимый
`char` в `&str` вы должны быть рады видеть этот пул реквест:
[теперь она в 10 раз быстрее](https://github.com/rust-lang/rust/pull/46735)!
Это благодаря `memchr`. `[u8]::contains` её так же
[использует](https://github.com/rust-lang/rust/pull/46713), но не получает
настолько экстремального ускорения.

Так же в этом релизе были стабилизированы несколько новых API:

- [RefCell::replace](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace)
- [RefCell::swap](https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.swap)
- [std::sync::atomic::spin_loop_hint](https://doc.rust-lang.org/std/sync/atomic/fn.spin_loop_hint.html)

Теперь следующие функции могут быть использованы в константных выражениях,
например, чтобы инициализировать `static`:
- new функции для `Cell`, `RefCell`, и `UnsafeCell`
- new функции для различных числовых атомик типов (примечание: AtomicBool,
AtomicIsize, AtomicUsize)
- {integer}::min_value и {integer}::max_value
- mem::size_of и mem::align_of
- ptr::null и ptr::null_mut

## Разработчики 1.24

Множество людей участвовало в разработке Rust 1.24. Мы не смогли бы этого
добиться без участия каждого из вас.
[Спасибо!](https://blog.rust-lang.org/2018/02/15/Rust-1.24.html)
