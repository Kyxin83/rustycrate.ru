Команда разработчиков Rust рада сообщить о выпуске новой версии Rust, 1.33.0. Rust — это язык программирования, который дает возможность каждому создавать надежное и эффективное программное обеспечение.

Если у вас установлена предыдущая версия Rust с помощью rustup, то для обновления Rust до версии 1.33.0 вам достаточно выполнить:

```
$ rustup update stable
```

Если у вас еще не установлен rustup, вы можете [установить его][install] с соответствующей страницы нашего веб-сайта.

[install]: https://www.rust-lang.org/install.html
[notes]: https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1340-2019-04-11

## Что вошло в стабильную версию 1.34.0

Основное улучшение этого выпуска это поддежка альтернативных cargo-реестров.
Релиз так же включает поддержку `?` в документационных текстах, некоторые улучшения в `#[attribute(...)]` и стабилизацию `TryFrom`.
Читайте далее о ключевых вещах или можете посмотреть [подробные примечания к выпуску][notes] для дополнительной информации.

### Альтернативные `cargo` реестры

[crates.io]: http://crates.io/
[registry-docs]: https://doc.rust-lang.org/nightly/cargo/reference/registries.html#running-a-registry

Ещё до версии 1.0 у Rust был публичный реестр, [crates.io].
Люди публиковали крейты при помощи `cargo publish` и легко подключали
эти крейты в секции `[dependencies]` в `Cargo.toml`.

Однако не все _хотели_ публиковать их крейты на crates.io.
Люди, поддерживающие проприетарные/с закрытым исходным кодом проекты,
не могла использовать crates.io, и вместо этого указывали `git` или `path`
в зависимостях.
Здесь нет ничего такого для небольших проектов, но если в вашей
большой организации есть много крейтов с закрытым кодом, вы теряете
преимущества поддержки версионирования, которое есть в crates.io.

С этим выпуском, Cargo может поддерживать альтернативные реестры.
Эти реестры сосуществуют с crates.io, так что вы можете писать программы,
которые зависят и от crates.io, и от вашего реестра.
Однако крейты на crates.io не могут зависеть от внешнего реестра.

Для использования альтернативных реестров, вы должны добавить следующие
строки в `.cargo/config`. Этот файл может быть в вашей домашней
директории (`~/.cargo/config`) или быть в диретории пакета.

```toml
[registries]
my-registry = { index = "https://my-intranet:8080/git/index" }
```

Добавить зависимость из альтернативного реестра легко.
Когда вы указываете зависимость в `Cargo.toml`, используйте ключ
`registry` чтобы Cargo знал что вы хотите получать крейт из альтернативного реестра:

```toml
[dependencies]
other-crate = { version = "1.0", registry = "my-registry" }
```

Как автор крейта, если вы хотите публиковать ваш крейт в
альтернативном реестре, первым делом вам надо сохранить
аутентификационный токен в `~/.cargo/credentials` при помощи команды
`cargo login`:

```sh
cargo login --registry=my-registry
```

Далее вы можете использовать флаг `--registry` для указания реестра,
который будет использоваться для публикации:

```sh
cargo publish --registry=my-registry
```

О том, как вы можете запустить свой собственный реестр, вы можете найти
в [документации][registry-docs].

### `?` в документационных тестах

[RFC 1937]: https://rust-lang.github.io/rfcs/1937-ques-in-main.html
[достаточно давно]: https://blog.rust-lang.org/2018/05/10/Rust-1.26.html#main-can-return-a-result

В [RFC 1937] было преложено добавить поддержку использования оператора
`?` в `fn main()`, `#[test]` фнкциях и документационных тестах, поволяя
им вернуть `Option<T>` или `Result<T, E>` со значением ошибки в
случае с `fn main()` и ... в случае с тестами.

Поддержка в `fn main()` и `#[test]` была реализована [достаточно давно].
Однако поддержка в документационных тестах была ограничена тестами,
в которых явно присутствовал `fn main()`.

В этом выпуске добавлена полная поддержка `?` в документационных тестах.
Теперь вы можете написать в ваших документационных тестах такое:

````rust
/// ```rust
/// use std::io;
/// let mut input = String::new();
/// io::stdin().read_line(&mut input)?;
/// # Ok::<(), io:Error>(())
/// ```
fn my_func() {}
````

Внизу документационного теста вам всё равно надоуказывать тип ошибки, который будет использован.

### Поддержка произвольного потока токенов в пользовательских аттрибутах

[Процедурные макросы]: https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html
[arbitrary-tts]: https://github.com/rust-lang/rust/pull/57367

[Процедурные макросы] в Rust могут определять пользовательские
аттрибуты, которые они используют. До текущего момента эти аттрибуты
были ограничены деревьями путей и литералами в соответствии со
следующим синтаксисом:

```rust
#[foo(bar)]
#[foo = "bar"]
#[foo = 0]
#[foo(bar = true)]
#[foo(bar, baz(quux, foo = "bar"))]
```

В отличии от процедурных макросов, эти вспомогательные аттрибуты
не могли принимать произвольный поток токенов в разделителе, из-за
чего вы не могли написать `#[range(0..10)]` или `#[bound(T: MyTrait)]`.
Крейты процедурных макросов вместо этого использовали строки для
синтаксиса, подобного такому, например `#[range("0..10")]`.

С этим выпуском, пользовательские аттрибуты `#[attr($tokens)]` [позволяют использовать][arbitrary-tts] произвольные токены в `$tokens`, приводя их в соответствии с макросами.
Если вы автор крейта процедурного макроса, пожалуйста проверьте
используются ли строки в синтаксисе ваших пользовательских аттрибутах
и можно ли их заменить на поток токенов.

### `TryFrom` и `TryInto`

[`from_be_bytes`]: https://doc.rust-lang.org/std/primitive.u32.html#method.from_be_bytes
[never_type]: https://github.com/rust-lang/rust/issues/35121
[`TryFrom`]: https://doc.rust-lang.org/std/convert/trait.TryFrom.html
[`TryInto`]: https://doc.rust-lang.org/std/convert/trait.TryInto.html
[`Infallible`]: https://doc.rust-lang.org/std/convert/enum.Infallible.html

Трейты [`TryFrom`] и [`TryInto`] были стабилизированы для поддержки
ошибок при преобразовании типов.

Например, [`from_be_bytes`] и связанне методы целочисленных типов
получают массив, но данные часто читаются через слайсы. Ручное
преобрвазование между слайсами и массивами утомительно. С новыми
трейтами это возможно сделать в одну строку с `.try_into()`.

```rust
let num = u32::from_be_bytes(slice.try_into()?);
```

Для преобразований, которые не могут упасть, таких как `u8` в `u32`,
добавлен тип [`Infallible`]. Это так же позволяет ... `TryFrom` для
всех существующих имплементаций `From`. В будущем, мы надеемся сделать
`Infallible` псевдонимом для [`!` (never) type][never_type].

